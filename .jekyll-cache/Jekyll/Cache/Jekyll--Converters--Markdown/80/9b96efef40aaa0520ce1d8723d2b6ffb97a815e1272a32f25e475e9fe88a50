I"Ώ‡<h3 id="introduction">Introduction</h3>
<p>NFT ν”„λ΅μ νΈμ—μ„ ν™”μ΄νΈ λ¦¬μ¤νΈ λ…λ‹¨λ§ NFT λ―Όν…μ΄ κ°€λ¥ν•κ² λ§λ“λ” μ‹λ‚λ¦¬μ¤μ²λΌ, νΉμ •ν• μ£Όμ† λ¦¬μ¤νΈλ“¤λ§ ν•¨μλ¥Ό μ‹¤ν–‰ν•  μ μλ„λ΅ μ¤λ§νΈ μ»¨νΈλ ‰νΈλ¥Ό μ‘μ„±ν•λ ¤λ©΄ μ–΄λ–»κ² ν•΄μ•Όν• κΉ? μ΄λ”λ¦¬μ›€μ μ €μ¥ κ³µκ°„κ³Ό λΉ„μ©μ— μ μ•½μ΄ μ—†λ‹¤λ©΄ λ¨λ“  μ£Όμ† λ¦¬μ¤νΈλ“¤μ„ Storageμ— λ§¤ν•‘ ν•νƒλ΅ μ €μ¥ν• ν›„, νΈλμ­μ… μ”μ²­ μ‹ msg.senderκ°€ λ§¤ν•‘ κ°’μ„ κ°–λ”μ§€ ν™•μΈν•λ” κ²ƒμ΄ ν•λ‚μ λ°©λ²•μΌ κ²ƒμ΄λ‹¤. ν•μ§€λ§ μ΄λ”λ¦¬μ›€ λ„¤νΈμ›ν¬λ” μ λ§μ€ μ»΄ν“¨ν„°κ°€ μƒνƒλ¥Ό κ³µμ ν•λ” μ›”λ“ μ»΄ν“¨ν„°λ΅μ„, μ΄λ¬ν• μ›”λ“ μ»΄ν“¨ν„°μ— λ°μ΄ν„°λ¥Ό μ €μ¥ν•λ” κ²ƒμ€ λ§μ€ λΉ„μ©μ΄ μ†λ¨λλ‹¤ (32 bytesμ wordλ¥Ό μ €μ¥ν•λ” κ²ƒμ€ ν†µμƒμ μΌλ΅ 20,000 gasλ¥Ό μ†λ¨, κΈ€μ“΄ μ‹μ  κΈ°μ¤€ μ•½ 8μ²μ›).</p>

<p>μ΄λ¬ν• κ³µκ°„κ³Ό λΉ„μ©μ λ¬Έμ λ¥Ό ν•΄κ²°ν•κΈ° μ„ν•΄, μ¤λ§νΈ μ»¨νΈλ ‰νΈμ—μ„λ” Merkle ProofλΌλ” λ°©μ‹μ„ μ‚¬μ©ν•λ‹¤. Merkle Proofλ¥Ό μ΄μ©ν•λ©΄ λ¨λ“  μ£Όμ† λ°μ΄ν„°λ¥Ό Storageμ— μ €μ¥ν•μ§€ μ•κ³ λ„, νΉμ • μ£Όμ† λ°μ΄ν„°κ°€ ν•¨μ μ‹¤ν–‰ ν—μ© μ£Όμ† λ©λ΅μ— λ“¤μ–΄κ°€λ”μ§€ μ•„λ‹μ§€λ¥Ό νλ‹¨ν•  μ μλ‹¤. μ¦‰ λ¨λ“  λ°μ΄ν„° (μ—¬κΈ°μ„  μ£Όμ† λ¦¬μ¤νΈ)λ¥Ό μ΄λ”λ¦¬μ›€ μ¨μ²΄μΈμ— μ €μ¥ν•μ§€ μ•κ³ λ„ μ•„μ£Ό μ‘μ€ μ¨μ²΄μΈ λ°μ΄ν„°λ§μΌλ΅λ„ (λ’¤μ— λ‚μ¬ Merkle Treeμ Root κ°’), νΉμ • λ°μ΄ν„°μ λ¬΄κ²°μ„±(Data integrity)μ„ κ²€μ¦ν•  μ μλ‹¤.</p>

<h3 id="merkle-proof-and-merkle-tree">Merkle Proof and Merkle Tree</h3>
<p>Merkle Proofλ” λ¨Έν΄ νΈλ¦¬(Merkle Tree)λ¥Ό μ‚¬μ©ν•λ‹¤. μ•„λ κ·Έλ¦Όκ³Ό κ°™μ΄ λ¨Έν΄ νΈλ¦¬μ Leaf λ…Έλ“λ” λ°μ΄ν„°μ ν•΄μ‹ κ°’μΌλ΅ κµ¬μ„±λμ–΄ μμΌλ©°, Leaf λ…Έλ“κ°€ μ•„λ‹ λ¨λ“  λ…Έλ“λ“¤μ€ μμ‹ λ…Έλ“ λ‘μ ν•΄μ‹ κ°’μ„ κ°€μ§„λ‹¤. Leaf λ…Έλ“μ λ°μ΄ν„° κ°’μ΄ ν•λ‚λΌλ„ λ³€κ²½λλ‹¤λ©΄, ν•΄μ‹ ν•¨μμ κ²°κ³Ό κ°’μ΄ κ³„μΈµλ§λ‹¤ μ—°μ‡„μ μΌλ΅ λ‹¬λΌμ§€κΈ° λ•λ¬Έμ— Root nodeμ ν•΄μ‹ κ°’μ΄ μ™„μ „ν λ‹¬λΌμ§€κ² λλ‹¤. μ°λ¦¬λ” μ΄ Root Hash κ°’λ§μ„ μ΄λ”λ¦¬μ›€ μ¨μ²΄μΈμ— μ €μ¥ν•¨μΌλ΅μ¨ νΉμ • λ°μ΄ν„°κ°€ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ— ν¬ν•¨λμ–΄ μλ”μ§€λ¥Ό κ²€μ¦ν•  μ μλ‹¤. μμ‹λ¥Ό λ“¤μ–΄ λ³΄μ.</p>

<p style="text-align: center;">
	<img src="http://localhost:4000/assets/images/MerkleProof/tree.png" alt="Drawing" style="max-width: 80%; height: auto;" />
</p>

<p>μ„ κ·Έλ¦Όμ—μ„ Leaf λ…Έλ“ H(K)κ°€ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ— ν¬ν•¨λλ‹¤λ” κ²ƒμ„ μ¤λ§νΈ μ»¨νΈλ ‰νΈμ—μ„ μ–΄λ–»κ² μ¦λ…ν•  μ μμ„κΉ? μ—¬κΈ°μ„ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ Root Hash κ°’ H(ABCDEFGHIJKLMNOP)μ€ μ¨μ²΄μΈμ— μ €μ¥λμ–΄ νΌλΈ”λ¦­ν•κ² κ³µκ°λμ–΄ μλ‹¤κ³  κ°€μ •ν•΄λ³΄μ. μ°λ¦¬λ” μ„ κ·Έλ¦Όμ—μ„ μƒ‰μΉ λ λ…Έλ“λ“¤λ§ μλ‹¤λ©΄ ν•΄μ‹ κ³„μ‚°μ„ ν†µν•΄ Root Hash κ°’μ„ λ„μ¶ν•  μ μλ‹¤. κ³„μ‚°μ€ λ‹¤μκ³Ό κ°™λ‹¤.</p>

<ol>
  <li>H(K)μ„ H(L)μ™€ ν•΄μ‹±ν•μ—¬ H(KL)μ„ κ³„μ‚°</li>
  <li>H(KL)μ„ H(IJ)μ™€ ν•΄μ‹±ν•μ—¬ H(IJKL)μ„ κ³„μ‚°</li>
  <li>H(IJKL)μ„ H(MNOP)μ™€ ν•΄μ‹±ν•μ—¬ H(IJKLMNOP)μ„ κ³„μ‚°</li>
  <li>H(IJKLMNOP)μ„ H(ABCDEFGH)μ™€ ν•΄μ‹±ν•μ—¬ Root HashμΈ H(ABCDEFGHIJKLMNOP)μ„ κ³„μ‚°</li>
</ol>

<p>λ”°λΌμ„ H(K)λ΅λ¶€ν„° Root Hash κ°’μ„ κµ¬ν•κΈ° μ„ν•΄μ„  [ H(K), H(L), H(IJ), H(MNOP), H(ABCDEFGH)] κ°’λ“¤μ΄ ν•„μ”ν•λ‹¤. μ„ κ³Όμ •μ„ ν†µν•΄ κ³„μ‚°λ Root Hash κ°’μ΄ λ―Έλ¦¬ μ¨μ²΄μΈμ— μ €μ¥λμ–΄ μλ Root Hash κ°’κ³Ό μΌμΉν•λ‹¤λ©΄ μ°λ¦¬λ” Leaf H(K)κ°€ H(ABCDEFGHIJKLMNOP)λ¥Ό Root Hashλ΅ κ°€μ§€λ” λ¨Έν΄ νΈλ¦¬μ— ν¬ν•¨λμ—λ‹¤κ³  νλ‹¨ν•  μ μλ‹¤.</p>

<p>Warning: μ„ ν•΄μ‹ν•¨μ κ³„μ‚° κ³Όμ •μ—μ„  ν•΄μ‹ν•¨μ νλΌλ―Έν„°λ“¤μ μμ„(order)λ¥Ό λ¬΄μ‹ν•μ€μ§€λ§, H(H(KL), H(IJ))μ κ°’μ€ H(H(IJ), H(KL))) κ°’κ³Ό μ „ν€ λ‹¤λ¥Ό μ μκΈ° λ•λ¬Έμ— μ‹¤μ  κµ¬ν„μ—μ„  νλΌλ―Έν„°μ μμ„ νΉμ€ Concat μμ„μ— μ μν•΄μ•Όν•λ‹¤. μ•„λ μ‚΄ν΄λ³Ό OpenZeppelin λΌμ΄λΈλ¬λ¦¬μ—μ„λ” H(IJ)μ™€ H(KL)μ κ°’μ ν¬κΈ°λ¥Ό λΉ„κµν•μ—¬ μ •λ ¬ν•λ‹¤. μ¦‰ H(IJ)κ°€ H(KL)λ³΄λ‹¤ ν΄ λ•, H(concat(H(IJ),H(KL)))μ„ μν–‰ν•κ³ , λ°λ€μ κ²½μ°μ—” H(concat(H(KL),H(IJ)))λ¥Ό μν–‰ν•λ‹¤.</p>

<p>μ„μ μμ μ²λΌ νΉμ • λ°μ΄ν„°(A to P)λ“¤μ μ§‘ν•©μ΄ μμ„ λ•, μ°λ¦¬λ” μ΄ λ°μ΄ν„°λ“¤μ ν•΄μ‹ κ°’μ„ Leaf λ…Έλ“λ΅ ν•μ—¬ λ¨Έν΄ νΈλ¦¬λ¥Ό κµ¬μ„±ν•  μ μλ‹¤. μ΄ λ• Merkle Proofλ” νΉμ • λ°μ΄ν„°κ°€ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ— μ†ν•΄μλ”μ§€λ¥Ό κ²€μ¦ν•λ” λ°©λ²•μ΄λ‹¤. μ¤λ§νΈ μ»¨νΈλ ‰νΈ μ¤ν† λ¦¬μ§€μ— λ¨Έν΄ νΈλ¦¬μ Root Hash κ°’μ„ λ―Έλ¦¬ μ €μ¥ν•κ³ , μ¶”ν›„ μ‚¬μ©μκ°€ νΉμ • λ°μ΄ν„°κ°€ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ— μ†ν•΄μλ”μ§€ μ¦λ…ν•κΈ° μ„ν•΄ Proofλ¥Ό μ „λ‹¬ν•  μ μλ‹¤. μ—¬κΈ°μ„ Proofλ” λ¨λ“  λ°μ΄ν„°λ¥Ό ν¬ν•¨ ν•  ν•„μ” μ—†μ΄, Root Hashλ¥Ό μ¬κµ¬μ„±ν•κΈ° μ„ν• μµμ†ν•μ κ°’λ“¤λ§μ„ ν¬ν•¨ν•λ©΄ λλ‹¤ (μ•μ„  μμ‹μ—μ„ Proofλ” λ¨λ“  λ°μ΄ν„° A,β€¦,P κ°€ μ•„λ‹ H(K), H(L), H(IJ), H(MNOP), H(ABCDEFGH)λ§ ν•„μ”ν•μ€λ‹¤).</p>

<h3 id="openzeppelinμ-merkle-proof-λΌμ΄λΈλ¬λ¦¬">OpenZeppelinμ Merkle Proof λΌμ΄λΈλ¬λ¦¬</h3>

<p>μ¤ν”μ ν”λ¦°(OpenZeppelin)μ—μ„λ” Merkle Proofλ¥Ό μ•μ „ν•κ³ , μ‰½κ² κµ¬ν„ν•  μ μλ„λ΅ λΌμ΄λΈλ¬λ¦¬λ¥Ό μ κ³µν•κ³  μλ‹¤. Merkle Treeμ™€ Proofλ¥Ό μƒμ„±ν•κΈ° μ„ν• <a href="https://github.com/OpenZeppelin/merkle-tree">Javascript λΌμ΄λΈλ¬λ¦¬</a>μ™€, μ΄λ¥Ό μ¨μ²΄μΈμƒμ—μ„ κ²€μ¦ν•κΈ° μ„ν• <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol">Merkle Proof μ†”λ¦¬λ””ν‹° λΌμ΄λΈλ¬λ¦¬</a>κ°€ λ³„κ°λ΅ μ΅΄μ¬ν•λ‹¤.</p>

<p>μ¤ν”μ ν”λ¦°μ λΌμ΄λΈλ¬λ¦¬μ—μ„  μ΄λ”λ¦¬μ›€ μ¤λ§νΈ μ»¨νΈλ ‰νΈλ¥Ό μ„ν• β€ν‘μ¤€β€ λ¨Έν΄ νΈλ¦¬(Standard Merkle Trees)λ¥Ό μ‚¬μ©ν•λ‹¤. μ¤νƒ λ‹¤λ“ λ¨Έν΄ νΈλ¦¬μ νΉμ§•μ€ λ‹¤μκ³Ό κ°™λ‹¤.</p>

<ul>
  <li>μ™„μ „ μ΄μ§„ νΈλ¦¬μ΄λ‹¤</li>
  <li>Leavesλ” ν¬κΈ°κ°€ ν° μλ¶€ν„° μ‘μ€ μμΌλ΅ μ •λ ¬λμ–΄ μλ‹¤</li>
  <li>Leavesλ” μΌλ ¨μ κ°’μ„ ABI encodingν• κ²°κ³Όμ΄λ‹¤</li>
  <li>Keccak256 ν•΄μ‹ν•¨μλ¥Ό μ‚¬μ©ν•λ‹¤</li>
  <li>Second preimage attacksλ¥Ό λ°©μ§€ν•κΈ° μ„ν•΄ Leavesλ” λ°μ΄ν„°λ¥Ό λ‘λ² ν•΄μ‹±ν• κ°’μ„ μ‚¬μ©ν•λ‹¤</li>
</ul>

<p>μ„ μ‚¬ν•­λ“¤ μ¤‘ μ•„λ 3κ°€μ§€ μ‚¬ν•­μ„ κ³ λ ¤ν•  λ• Leafλ” μ†”λ¦¬λ””ν‹°μ—μ„ μ•„λμ™€ κ°™μ΄ ν‘ν„λλ‹¤.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes32</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="kt">bytes</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">amount</span><span class="p">))));</span>
</code></pre></div></div>

<p>κ·ΈλΌ μ΄μ  μλ°”μ¤ν¬λ¦½νΈ λΌμ΄λΈλ¬λ¦¬λ¥Ό ν†µν•΄ μ¤νƒ λ‹¤λ“ νΈλ¦¬λ¥Ό κµ¬μ„±ν•΄λ³΄μ. β€npm install @openzeppelin/merkle-treeβ€ λ…λ Ήμ–΄λ¥Ό ν†µν•΄ ν¨ν‚¤μ§€λ¥Ό μ„¤μΉν•  μ μλ‹¤. μ°λ¦¬λ” μλ°”μ¤ν¬λ¦½νΈ λΌμ΄λΈλ¬λ¦¬λ¥Ό ν†µν•΄ ν•„μ”ν• λ°μ΄ν„°λ΅λ¶€ν„° Merkle Treeλ¥Ό μƒμ„±ν•κ³ , νΉμ • λ°μ΄ν„°μ Proofλ¥Ό μ¶λ ¥ν•  μ μλ‹¤. λν• Treeλ¥Ό Json νμΌλ΅ μ €μ¥ν•μ—¬, νΌλΈ”λ¦­μ— κ³µκ°ν•΄ λ„κµ¬λ‚ treeλ¥Ό μ¬κµ¬μ„±ν•κ³ , proofλ¥Ό μƒμ„±ν•λ„λ΅ λ§λ“¤ μ μλ‹¤. μ•„λ μμ λ¥Ό μ‚΄ν΄λ³΄μ.</p>

<pre><code class="language-Javascript">import { StandardMerkleTree } from "@openzeppelin/merkle-tree";
import fs from "fs";

// (1) Data
const values = [
  ["0x1111111111111111111111111111111111111111", "3000000000000000000"],
  ["0x2222222222222222222222222222222222222222", "0"],
  ["0x3333333333333333333333333333333333333333", "30"],
  ["0x4444444444444444444444444444444444444444", "1500000000000000000"],
];

// (2) λ°μ΄ν„°λ΅λ¶€ν„° StandardMerkleTree μƒμ„±
const tree = StandardMerkleTree.of(values, ["address", "uint256"]);

// (3) μƒμ„±ν• standard merkle tree μ¶λ ¥
console.log("Tree:\n" + tree.render());

// (4) μƒμ„±ν• λ¨Έν΄ νΈλ¦¬λ¥Ό json fileλ΅ μ €μ¥
fs.writeFileSync("tree.json", JSON.stringify(tree.dump()));

// (5) json νμΌλ΅ μ €μ¥λ λ¨Έν΄ νΈλ¦¬λ¥Ό λ¶λ¬μ¤κΈ°
const tree_load = StandardMerkleTree.load(JSON.parse(fs.readFileSync("tree.json")));

// (6) λ‚΄κ°€ μ›ν•λ” λ°μ΄ν„°μ indexλ¥Ό μ°ΎκΈ° μ„ν•΄ entries() ν•¨μλ¥Ό ν†µν• Loopλ¬Έ μ‹¤ν–‰
for (const [i, v] of tree_load.entries()) {
 if (v[0] === '0x1111111111111111111111111111111111111111') {
   // (7) entryμ indexλ¥Ό μ‚¬μ©ν•΄ μ›ν•λ” λ°μ΄ν„°μ proofλ¥Ό μƒμ„±
   const proof = tree_load.getProof(i);
   console.log('Value:', v);
   console.log('Proof:', proof);
 }
}
</code></pre>

<p>μ„ μ½”λ“μ—μ„, μ°λ¦¬λ” ν•λ‚μ λ°μ΄ν„°λ¥Ό [β€addressβ€, β€uint256β€] κ°’μΌλ΅ κµ¬μ„±ν•μ€λ‹¤. (2)λ² StandardMerkleTreeλ¥Ό μƒμ„±ν•λ” κ³Όμ •μ—μ„ μ΄λ¬ν• λ°μ΄ν„° Typeμ„ μ•λ ¤μ¤μΌλ΅μ¨ λΌμ΄λΈλ¬λ¦¬κ°€ Solidity ABI.encodeμ— λ§μ¶° λ°μ΄ν„°λ¥Ό μΈμ½”λ”© ν•  μ μκ²ν•λ‹¤.</p>

<p>(3)λ²μ—μ„ tree.render() ν•¨μλ¥Ό ν†µν•΄ μ½μ†”μ— μ¶λ ¥ν• λ¨Έν΄ νΈλ¦¬μ κ°’μ€ μ•„λμ™€ κ°™λ‹¤. 3, 4, 5, 6λ² λ…Έλ“λ” Leaf λ…Έλ“λ΅μ„, μ•μ„ λ§ν• Standard Merkle Treeμ νΉμ§•μΌλ΅ λ§ν– λ“― Dataλ¥Ό κ·Έλ€λ΅ μ‚¬μ©ν•μ§€ μ•κ³  λ°μ΄ν„°μ— λ€ν•΄ Kecca256 ν•΄μ‹ν•¨μλ¥Ό λ‘λ² μ‹¤ν–‰ν• κ°’μ΄λ‹¤. μ—¬κΈ°μ„ 0λ² λ…Έλ“μΈ β€b56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27β€ κ°’μ€ Root Hash κ°’μΌλ΅μ„ μ»¨νΈλ ‰νΈμ— κ³µκ°μ μΌλ΅ μ €μ¥λμ–΄μ•Όν•  κ°’μ΄λ‹¤.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:
0) b56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27
β”β”€ 1) 5cad1d68954860301ed48598eea08649201682d2b50c9977d697cb153e0d3618
β”‚  β”β”€ 3) fdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2f
β”‚  β””β”€ 4) 81722ecd3bc2b003be5b8850a4de98dc3e991dd001e8173e408de279c388bc2e
β””β”€ 2) b77c1086d6ac2a0e454607cbe31c25dd5736f1bf9c147a6de93cc7121b7d210b
   β”β”€ 5) 43ab72a115a26a347338741504964163dea922ee399341883ba5705ea9a4f7d6
   β””β”€ 6) 4358fbda895975ea76fcee263adef8867647f91879de2c1a3c257821709287a5
</code></pre></div></div>

<p>μ—¬κΈ°μ„ Leaf λ…Έλ“μ μμ„λ” λ°μ΄ν„°μ μ…λ ¥ μμ„(Values λ°°μ—΄μ μΈλ±μ¤ μμ„)κ°€ μ•„λ‹λΌλ” μ μ„ λ…μ‹¬ν•΄μ•Όν•λ‹¤. Leaf λ…Έλ“λ” μ•μ„ λ§ν– λ“―, ν¬κΈ°μ— λ”°λΌ β€μ •λ ¬β€™λλ‹¤. μ²«λ²μ§Έ Leaf λ…Έλ“ β€fdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2fβ€κ°€ κ°€μ¥ ν° κ°’μ„ κ°€μ§μ„ ν™•μΈν•  μ μμΌλ©° μ΄ κ°’μ€ Values[0]μΈ [β€0x1111111111111111111111111111111111111111β€, β€3000000000000000000β€]μ„ λ‘λ² ν•΄μ‹±ν• κ°’μ΄ μ•„λ‹, Values[3]μ„ λ‘λ² ν•΄μ‹±ν• κ°’μ΄λ‹¤. μ•„λ μ½”λ“λ¥Ό ν†µν•΄ μ°λ¦¬λ” μ΄λ¥Ό ν™•μΈν•  μ μλ‹¤.</p>

<pre><code class="language-Javascript">const leaf = tree.leafHash(values[3]);
console.log("Leaf of values[3]: " + leaf);
</code></pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Leaf of values[3]: 0xfdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2f
</code></pre></div></div>

<p>μ¦‰, μ¤ν”μ ν”λ¦°μ—μ„ μ‚¬μ©ν•λ” ν‘μ¤€ λ¨Έν΄ νΈλ¦¬μ—μ„  λ°μ΄ν„°λ“¤μ— λ€ν•΄ Kecca256 ν•΄μ‹ ν•¨μλ¥Ό μ‹¤ν–‰ν•μ—¬ ν•΄μ‹ κ°’μ„ λ¨Όμ € κµ¬ν• ν›„, ν¬κΈ°κ°€ ν° μμΌλ΅ μ •λ ¬ν•μ—¬ Leaf λ…Έλ“λ΅ μ‚Όλ”λ‹¤.</p>

<p>λ‹¤μ‹ λ³Έλ μ½”λ“λ΅ λμ•„μ™€ (6)λ² κ³Όμ •μ„ μ‚΄ν΄λ³΄μ.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (6) λ‚΄κ°€ μ›ν•λ” λ°μ΄ν„°μ indexλ¥Ό μ°ΎκΈ° μ„ν•΄ entries() ν•¨μλ¥Ό ν†µν• Loopλ¬Έ μ‹¤ν–‰</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">tree_load</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">0x1111111111111111111111111111111111111111</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// (7) entryμ indexλ¥Ό μ‚¬μ©ν•΄ μ›ν•λ” λ°μ΄ν„°μ proofλ¥Ό μƒμ„±</span>
   <span class="kd">const</span> <span class="nx">proof</span> <span class="o">=</span> <span class="nx">tree_load</span><span class="p">.</span><span class="nx">getProof</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Value:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Proof:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">proof</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>μ°λ¦¬λ” μƒμ„±ν• λ¨Έν΄ νΈλ¦¬μ—μ„ νΉμ • λ°μ΄ν„°λ¥Ό μ„ν• Proofλ¥Ό μƒμ„±ν•  μ μλ‹¤. μμ μ—μ„ , β€0x1111111111111111111111111111111111111111β€μ μ£Όμ†λ¥Ό κ°€μ§„ λ°μ΄ν„°λ¥Ό μ„ν•΄ Proofλ¥Ό μƒμ„±ν•λ‹¤. Proofλ¥Ό μ¶λ ¥ν• κ²°κ³Όλ” λ‹¤μκ³Ό κ°™λ‹¤.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proof: [
  '0x4358fbda895975ea76fcee263adef8867647f91879de2c1a3c257821709287a5',
  '0x5cad1d68954860301ed48598eea08649201682d2b50c9977d697cb153e0d3618'
]
</code></pre></div></div>

<p>μ°λ¦¬λ” μ΄ Proofλ¥Ό β€0x1111111111111111111111111111111111111111β€μ Leaf ν•΄μ‹ κ°’κ³Ό ν•¨κ» μ¤λ§νΈ μ»¨νΈλ ‰νΈμ— λ³΄λ‚΄λ©΄ μ»¨νΈλ ‰νΈλ” μ΄λ¥Ό ν†µν•΄ Root hash κ°’μ„ λ„μ¶ν•  μ μλ‹¤. λ„μ¶λ κ°’μ΄ μ»¨νΈλ ‰νΈμ— μ¤ν† λ¦¬μ§€μ— μ‚¬μ „μ— μ €μ¥λ Root Hash κ°’μΈ β€b56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27β€κ³Ό λ™μΌν•λ‹¤λ©΄, μ¤λ§νΈ μ»¨νΈλ ‰νΈλ” μ΄ λ°μ΄ν„°κ°€ ν•΄λ‹Ή λ¨Έν΄ νΈλ¦¬μ— μ†ν•΄μλ” λ°μ΄ν„°λΌκ³  νλ‹¨ν•  μ μλ‹¤.</p>

<p>κ·ΈλΌ μ„ κ³Όμ •μ„ μ¤λ§νΈ μ»¨νΈλ ‰νΈμ—μ„ μ‹¤μ λ΅ μ–΄λ–»κ² κµ¬ν„ν–λ”μ§€ <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol">μ¤ν”μ ν”λ¦°μ μ»¨νΈλ ‰νΈ λΌμ΄λΈλ¬λ¦¬</a>λ¥Ό μ‚΄ν΄λ³΄μ.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">library</span> <span class="n">MerkleProof</span> <span class="p">{</span>
    <span class="cm">/**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */</span>
    <span class="k">function</span> <span class="n">verify</span><span class="p">(</span>
        <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">proof</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="n">root</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="n">leaf</span>
    <span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">processProof</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">==</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs &amp; pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */</span>
    <span class="k">function</span> <span class="n">processProof</span><span class="p">(</span><span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">proof</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">leaf</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="n">computedHash</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">proof</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">computedHash</span> <span class="o">=</span> <span class="n">_hashPair</span><span class="p">(</span><span class="n">computedHash</span><span class="p">,</span> <span class="n">proof</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">computedHash</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">_hashPair</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">/// @solidity memory-safe-assembly
</span>        <span class="k">assembly</span> <span class="p">{</span>
            <span class="n">mstore</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">mstore</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">:=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>μ„ μ½”λ“λ” λ³Έλ λΌμ΄λΈλ¬λ¦¬μ—μ„ verifyμ™€ κ΄€λ ¨λ ν•¨μλ§μ„ λ³΄μ—¬μ¤€λ‹¤. verifyλ” μ°λ¦¬κ°€ μ•μ„ μλ°”μ¤ν¬λ¦½νΈ λΌμ΄λΈλ¬λ¦¬μ—μ„ κµ¬ν–λ Proof κ°’, Merkle Treeμ Root Hash κ°’, Leaf κ°’μ„ μ „λ‹¬λ°›μΌλ©°, Leafμ™€ Proofλ¥Ό ν†µν•΄ μ¬κ³„μ‚°λ Root Hash κ°’μ΄ νλΌλ―Έν„°λ΅ μ „λ‹¬λ root λ³€μμ™€ μΌμΉν•λ”μ§€λ¥Ό νλ‹¨ν•λ‹¤.</p>

<p>λΌμ΄λΈλ¬λ¦¬λ¥Ό μ‚¬μ©ν•λ” μ…μ¥μ—μ„ μ„Έλ¶€ κµ¬ν„κΉμ§€ μ• ν•„μ”λ” μ—†μ§€λ§, _hashPair ν•¨μλ¥Ό μ‚΄ν΄λ³΄μ. μ•μ„ Warning κµ¬λ¬Έμ—μ„ μ–ΈκΈ‰ν–λ“―μ΄, Hash(A,B)μ™€ Hash(B,A)λ” ν° μ°¨μ΄λ¥Ό κ°€μ§„λ‹¤. _hashPair ν•¨μμ—μ„  A, Bμ μ¤‘ ν° κ°’μ„ κ°€μ§„ bytes32 κ°’μ„ μ²«λ²μ§Έ νλΌλ―Έν„°λ΅ μ‚Όλ”λ‹¤. μ»¨νΈλ ‰νΈμ—μ„λ” μ΄λ¬ν• κΈ°μ¤€μ„ ν†µν•΄ λ‘κ°μ μμ‹ λ…Έλ“λ΅λ¶€ν„° λ¶€λ¨ λ…Έλ“μ ν•΄μ‹ κ°’μ„ κ³„μ‚°ν•  λ• μμ„μ— λ€ν•΄ κ³ λ―Όν•  ν•„μ”κ°€ μ—†λ‹¤.</p>

<p>λ§μ§€λ§‰μΌλ΅ _efficientHash ν•¨μμ—μ„λ” μ‹¤μ λ΅ ν•΄μ‹ ν•¨μκ°€ μ‹¤ν–‰λλ” λ¶€λ¶„μ΄λ©° μλ°”μ¤ν¬λ¦½νΈμ™€ λ§μ°¬κ°€μ§€λ΅ Keccak256 ν•΄μ‹ν•¨μλ¥Ό μ‚¬μ©ν•λ‹¤. μ—¬κΈ°μ„λ” κ°€μ¤ λΉ„μ©μ„ μ μ•½ν•κΈ° μ„ν•΄ assemblyλ¥Ό μ‚¬μ©ν•μ€λ‹¤. assemblyμ λ™μ‘ κ³Όμ •μ€ λ‹¤μκ³Ό κ°™λ‹¤.</p>

<ol>
  <li>mstore(0x00, a)λ” bytes32 a κ°’μ„ 0x00 λ©”λ¨λ¦¬ μ„μΉμ— μ €μ¥ν•λ‹¤.</li>
  <li>mstore(0x20, b)λ” bytes32 b κ°’μ„ 0x20 (10 μ§„μλ΅ 32) λ©”λ¨λ¦¬ μ„μΉμ— μ €μ¥ν•λ‹¤.</li>
  <li>keccak256(0x00, 0x40)λ” λ©”λ¨λ¦¬ 0x00λ¶€ν„° 0x40 (10 μ§„μλ΅ 64) κΈΈμ΄λ§νΌμ λ©”λ¨λ¦¬λ¥Ό ν•΄μ‹±ν•λ‹¤.</li>
</ol>

<h3 id="nft-ν”„λ΅μ νΈμ—μ„μ-μ‹¤μ -ν™μ©">NFT ν”„λ΅μ νΈμ—μ„μ μ‹¤μ  ν™μ©</h3>

<p>μ•μ„ Introμ—μ„ κ°„λ‹¨ν λ§ν– λ“―, λ§μ€ NFT ν”„λ΅μ νΈμ—μ„ White list (WL) λ―Όν…μ„ μ§„ν–‰ν•κ³ μ ν•  λ• λ¨Έν΄ νΈλ¦¬λ¥Ό μ‚¬μ©ν•λ‹¤. λ¨λ“  WL μ£Όμ†λ¥Ό μ¨μ²΄μΈμ— μ €μ¥ν•  ν•„μ” μ—†μ΄, μ£Όμ† λ°μ΄ν„°λ΅ κµ¬μ„±λ λ¨Έν΄ νΈλ¦¬μ Root Hash κ°’λ§ μ¨μ²΄μΈμ— μ €μ¥ν•λ©΄ λκΈ° λ•λ¬Έμ΄λ‹¤. μ•„λλ” μ¤ν”μ ν”λ¦°μ λΌμ΄λΈλ¬λ¦¬λ¥Ό ν™μ©ν•λ” ν…μ¤νΈ μ»¨νΈλ ‰νΈμ΄λ‹¤. Mint ν•¨μλ¥Ό μ‹¤ν–‰ν•κ³ μ ν•λ” νΈλμ­μ…μ msg.senderκ°€ λ¨Έν΄ νΈλ¦¬μ— ν¬ν•¨λμ–΄ μλ”μ§€λ¥Ό κ²€μ¦ν•λ‹¤. λ‹¨μν•¨μ„ μ„ν•΄ μµλ€ν• κ°„κ²°ν•κ² μ‘μ„±λμ—λ‹¤.</p>

<pre><code class="language-Solidity">// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.10;

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MerkleTest is ERC721 {
    /// @notice Merkle root of mint mintlist.
    bytes32 public immutable merkleRoot;
    /// @notice Id of the most recently minted.
    uint256 public id;
    /// @notice Mapping to keep track of which addresses have claimed from mintlist.
    mapping(address =&gt; bool) public hasClaimedMintlist;

    error AlreadyClaimed();
    error InvalidProof();

    /// @param _merkleRoot Merkle root of mint mintlist.
    constructor(bytes32 _merkleRoot) ERC721("Your NFT", "TEST"){
        merkleRoot = _merkleRoot;   
    }


    /// limit is enforced during the creation of the merkle proof, which will be shared publicly.
    /// @param proof Merkle proof to verify the sender is mintlisted.
    /// @return nftId The id of the gobbler that was claimed.
    function allowlistMint(bytes32[] calldata proof) external returns (uint256 nftId) {

        // If the user has already claimed, revert.
        if (hasClaimedMintlist[msg.sender]) revert AlreadyClaimed();

        // Calculate leaf from msg.sender value
        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(msg.sender))));

        // If the user's proof is invalid, revert.
        if (!MerkleProof.verify(proof, merkleRoot, leaf)) revert InvalidProof();

        hasClaimedMintlist[msg.sender] = true;

        _mint(msg.sender, id++);

        return id;
    }

}
</code></pre>
<p>μ„ μ½”λ“λ¥Ό μ‚΄ν΄λ³΄λ©΄, μƒμ„±μ (constructor) ν•¨μμ—μ„ Merkle Treeμ Root Hash κ°’μ„ μ…λ ¥λ°›κ³  μμΌλ©°, μ΄λ” merkleRoot λ³€μμ— μ €μ¥λλ‹¤. μ΄λ” WL μ£Όμ† λ°μ΄ν„°λ“¤μ„ κΈ°λ°μΌλ΅ μƒμ„±ν• λ¨Έν΄ νΈλ¦¬μ Root Hash κ°’μ„ μ»¨νΈλ ‰νΈ Deploy μ‹μ μ— μ…λ ¥ν•΄μ•Ό ν•λ‹¤λ” κ²ƒμ„ μλ―Έν•λ©°, νΉμ • μ£Όμ†κ°€ proof κ°’κ³Ό ν•¨κ» mintλ¥Ό μ”μ²­ν•  λ• μ¬κ³„μ‚°λ Root Hash κ°’μ„ merkleRoot λ³€μμ™€ λΉ„κµν•λ‹¤. μ¬κ³„μ‚°λ ν•΄μ‹ κ°’μ΄ merkleRoot λ³€μμ™€ μΌμΉν•  κ²½μ° μ°λ¦¬λ” ν•΄λ‹Ή μ£Όμ†κ°€ WL μ£Όμ† λ©λ΅μ— ν¬ν•¨λλ‹¤λ” κ²ƒμ„ ν™•μΈν•  μ μλ‹¤. μ΄λ¬ν• κ³Όμ •μ΄ allowlistMint ν•¨μμ— λ‹΄κ²¨μλ‹¤.</p>

<p>allowlistMint ν•¨μμ—μ„  msg.sender κ°’μ„ κΈ°λ°μΌλ΅ Leafλ¥Ό κ³„μ‚°ν•λ‹¤. μ—¬κΈ°μ„  standard merkle treeμ κΈ°μ¤€μ— λ”°λΌ Keccak256 ν•΄μ‹ν•¨μλ¥Ό λ‘λ² μ‚¬μ©ν•μ€μΌλ©°, ABI encodingμ„ μ‚¬μ©ν•λ‹¤. <code class="language-plaintext highlighter-rouge">if (!MerkleProof.verify(proof, merkleRoot, leaf))</code>μ—μ„λ” μ μ €κ°€ μ μ¶ν• proofμ™€ μ μ €μ μ£Όμ†λ΅ κ³„μ‚°λ leafλ¥Ό ν†µν•΄ λ¨Έν΄ νΈλ¦¬μ Root hash κ°’μ„ κ³„μ‚°ν•λ©°, μ΄λ¥Ό merkleRoot κ°’κ³Ό λΉ„κµν•λ‹¤. μΌμΉν•μ§€ μ•λ”λ‹¤λ©΄, if λ¬Έμ΄ μ°Έμ΄λλ―€λ΅ errorκ°€ λ°μƒν•λ‹¤. λ§μ•½ μΌμΉν•λ‹¤λ©΄, <code class="language-plaintext highlighter-rouge">hasClaimedMintlist[msg.sender] = true;</code>λ¥Ό ν†µν•΄ ν•΄λ‹Ή μ£Όμ†κ°€ λ―Όν…μ„ μν–‰ν–μμ„ κΈ°λ΅ν•μ—¬ μ¶”ν›„ λ‹¤μ‹ λ―Όν…μ„ ν•μ§€ λ»ν•λ„λ΅ ν•λ‹¤. λ§μ§€λ§‰μΌλ΅ ERC721λ΅λ¶€ν„° μƒμ†λ°›μ€ ν•¨μμΈ <code class="language-plaintext highlighter-rouge">_mint(msg.sender, id++);</code>λ¥Ό ν†µν•΄ μ‹¤μ  NFT λ―Όν…μ„ μν–‰ν•λ‹¤.</p>

<p>μ΄μ  <a href="https://remix.ethereum.org/">Remix IDE</a>λ¥Ό ν†µν•΄ μ„μ μ½”λ“λ¥Ό μ‹¤μ λ΅ ν…μ¤νΈν•΄λ³΄μ. ν•΄λ‹Ή μ½”λ“λ¥Ό ν…μ¤νΈν•κΈ°μ— μ•μ„ μ°λ¦¬λ” WL μ£Όμ† λ©λ΅λ“¤μ Merkle Treeλ¥Ό λ―Έλ¦¬ μƒμ„±ν•΄ Root Hash κ°’μ„ κµ¬ν•΄μ•Όν•λ‹¤. μ΄λ¥Ό μ„ν•΄ μ•„λ μλ°”μ¤ν¬λ¦½νΈ μ½”λ“μ—μ„  μ£Όμ† 4κ°λ΅ κµ¬μ„±λ λ¨Έν΄ νΈλ¦¬λ¥Ό μƒμ„±ν•μ€λ‹¤. λν•, Remix IDEμ—μ„ ν…μ¤νΈν•  μ£Όμ†μΈ β€0x5B38Da6a701c568545dCfcB03FcB875f56beddC4β€ μ£Όμ†μ— λ€ν• Proofλ¥Ό μƒμ„±ν•λ‹¤.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">StandardMerkleTree</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@openzeppelin/merkle-tree</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">allowlist</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>

<span class="kd">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">StandardMerkleTree</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">allowlist</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">address</span><span class="dl">"</span><span class="p">]);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Merkle Root:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">root</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">proof</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">getProof</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Address:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Proof:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">proof</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>μ„ μλ°”μ¤ν¬λ¦½νΈμ μ‹¤ν–‰ κ²°κ³Όλ” λ‹¤μκ³Ό κ°™λ‹¤. μ°λ¦¬λ” Merkle Rootμ κ°’ β€0x392dd2679d5481c8d088bcb22272b2054d3939e240c64da9834995e924192bcdβ€μ„ μ»¨νΈλ ‰νΈ Deploy μ‹μ μ— μ…λ ¥ν•΄μ•Όν•λ©°, Proof κ°’μ„ <code class="language-plaintext highlighter-rouge">allowlistMint</code> ν•¨μ νΈμ¶ μ‹μ μ— μ…λ ¥ν•΄μ•Όν•λ‹¤.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Merkle Root: 0x392dd2679d5481c8d088bcb22272b2054d3939e240c64da9834995e924192bcd
Address: [ '0x5B38Da6a701c568545dCfcB03FcB875f56beddC4' ]
Proof: [
  '0x56380595800b450765bcee141fd0b9ded9d8bfc454bd205dd31154e2d4bd104f',
  '0xb4422d6cb3cccffbfad08f58e6c0c8fdc1bcbbe3d198eafb4175d29290b5854f'
]
[Finished in 1.037s]
</code></pre></div></div>

<p>κ·ΈλΌ μ΄μ  Remix IDEλ¥Ό ν†µν•΄ μ„μ μ†”λ¦¬λ””ν‹° μ½”λ“λ¥Ό λ°°ν¬ν•΄λ³΄μ. Deployμ μΈμλ΅ μ„μ—μ„ κµ¬ν• λ¨Έν΄ νΈλ¦¬μ Root Hash κ°’μΈ <code class="language-plaintext highlighter-rouge">0x392dd2679d5481c8d088bcb22272b2054d3939e240c64da9834995e924192bcd</code>λ¥Ό μ…λ ¥ν•΄μ£Όμ. Deployλ¥Ό λ„λ¥΄λ©΄ μ„±κ³µμ μΌλ΅ λ°°ν¬λμ—λ‹¤λ” λ©”μ‹μ§€λ¥Ό λ³Ό μ μλ‹¤.</p>

<p style="text-align: center;">
	<img src="http://localhost:4000/assets/images/MerkleProof/deploy.png" alt="Drawing" style="max-width: 100%; height: 100%;" />
</p>

<p>κ·ΈλΌ μ΄μ  mintλ¥Ό μ§„ν–‰ν•΄λ³΄μ. <code class="language-plaintext highlighter-rouge">allowlistMint</code> ν•¨μμ νλΌλ―Έν„°λ΅ proofμΈ  <code class="language-plaintext highlighter-rouge">["0x56380595800b450765bcee141fd0b9ded9d8bfc454bd205dd31154e2d4bd104f", "0xb4422d6cb3cccffbfad08f58e6c0c8fdc1bcbbe3d198eafb4175d29290b5854f"]</code>μ„ νλΌλ―Έν„°λ΅ allowlistMint λ²„νΌμ„ ν΄λ¦­ν•λ‹¤. fromμ΄ 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4μ΄ λ¨Έν΄ νΈλ¦¬μ— μ†ν•΄μμΌλ―€λ΅ μ„±κ³µμ μΌλ΅ λ―Όν…μ΄ μν–‰λμμ„ μ• μ μλ‹¤. λ‹¤λ§ νΈλμ­μ…μ„ μ‹¤ν–‰ν• μ£Όμ†κ°€ 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4μ΄ μ•„λ‹λΌλ©΄ νΈλμ­μ…μ€ μ‹¤ν¨ν•  κ²ƒμ΄λ‹¤. remixμ—μ„ μ‚¬μ©ν•  μ μλ” 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 μ£Όμ†λ” μ–΄λ PC ν™κ²½μ—μ„λ„ λ‘κ°™μ΄ μ‚¬μ©ν•  μ μμΌλ―€λ΅ μ΄λ¥Ό ν…μ¤νΈ ν•΄λ³Ό μ μμ„ κ²ƒμ΄λ‹¤.</p>

<p style="text-align: center;">
	<img src="http://localhost:4000/assets/images/MerkleProof/mint.png" alt="Drawing" style="max-width: 100%; height: 100%;" />
</p>

<p>ν•λ² λ” κ°™μ€ ν•¨μλ¥Ό μ‹¤ν–‰ν•΄λ³΄μ. 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 μ£Όμ†λ΅ μ΄λ―Έ λ―Όν…μ„ μ§„ν–‰ν–μΌλ―€λ΅ AlreadyClaimed μ—λ¬κ°€ μ¶λ ¥λλ” κ²ƒμ„ λ³Ό μ μλ‹¤.</p>
<p style="text-align: center;">
	<img src="http://localhost:4000/assets/images/MerkleProof/AlreadyClaimed.png" alt="Drawing" style="max-width: 100%; height: 100%;" />
</p>

<h3 id="κ²°λ΅ ">κ²°λ΅ </h3>

<p>μ΄λ² ν¬μ¤ν…μ—μ„ Merkle Treeμ™€ Merkle Proofμ— λ€ν•΄ κ°„λµν μ„¤λ…ν–μΌλ©°, μ¤ν”μ ν”λ¦°μ Merkle Proof λΌμ΄λΈλ¬λ¦¬λ¥Ό μ‚΄ν΄λ³΄μ•λ‹¤. μ¤ν” μ ν”λ¦°μ λΌμ΄λΈλ¬λ¦¬λ¥Ό ν†µν•΄ λ†’μ€ λ³΄μ• μμ¤€μ Merkle Proof κµ¬ν„μ„ μ‰½κ² μ‚¬μ©ν•  μ μλ‹¤. μ‹¤μ λ΅λ„ μ•”νΈν™” μ”μ†λ¥Ό μ§μ ‘ κµ¬ν„ν•λ” κ²ƒλ³΄λ‹¤ μ΄λ ‡κ² μ Auditλ λΌμ΄λΈλ¬λ¦¬λ¥Ό μ‚¬μ©ν•λ” κ²ƒμ„ κ¶μ¥ν•λ‹¤.</p>

<p>λ§μ€ NFT ν”„λ΅μ νΈκ°€ Merkle Proofλ¥Ό ν†µν•΄ νΉμ • μ£Όμ†λ“¤λ§ Mintλ¥Ό μν–‰ν•  μ μλ” κΈ°λ¥μ„ κµ¬μ¶•ν•κ³  μμΌλ©°, μ°λ¦¬λ” μ¨μ²΄μΈμ— λ¨λ“  λ°μ΄ν„°λ¥Ό μ €μ¥ν•  ν•„μ”κ°€ μ—†λ‹¤! λ‹¤λ§, Merkle Treeλ¥Ό μ μ €λ“¤μ΄ μ¬κµ¬μ¶•ν•λ ¤λ©΄ μ΄ Merkle Treeκ°€ μ™Έλ¶€μ— κ³µκ°λμ–΄μ•Όν•λ‹¤. μΆ€ λ” μ–΄λ ¤μ΄ μ©μ–΄λ΅ λ§ν•μλ©΄, μ°λ¦¬λ” Merkle Proofλ¥Ό ν†µν•΄ λ°μ΄ν„° λ¬΄κ²°μ„±(Data integrity)λ¥Ό μ¦λ…ν•  μ μμ§€λ§, λ°μ΄ν„° κ°€μ©μ„±(Data availability) λ¬Έμ λ¥Ό ν•΄κ²°ν•μ§€λ” λ»ν•λ‹¤. 
μ΄λ¥Ό μ„ν•΄ λ¨Έν΄ νΈλ¦¬λ” IPFS κ°™μ€ λ¶„μ‚° μ¤ν† λ¦¬μ§€μ™€ ν•¨κ» μ‚¬μ©λλ‹¤.</p>

<p>Merkle Proofλ” Layer2 μ²΄μΈμΈ μµν‹°λ―Έμ¦, μ•„λΉ„νΈλΌ λ“±μ—μ„λ„ ν™μ©λλ”λ° Merkle Treeκ°€</p>

<!--
### Gas Optimization (Assembly)
//μ„μ OpenZeppelinμ΄ μ‘μ„±ν• μ¤λ§νΈ μ»¨νΈλ ‰νΈ μ½”λ“λ” μ–΄μ…λΈ”λ¦¬λ¥Ό μ‚¬μ©ν•μ§€ μ•κ³  λ™μ‘ν•λ‹¤. λ€λ¶€λ¶„μ ν”„λ΅μ νΈλ“¤μ€ ν•΄λ‹Ή λΌμ΄λΈλ¬λ¦¬λ¥Ό μ‚¬μ©ν•λ” κ²ƒμ„ μ¶”μ²ν•λ‹¤. λ‹¤λ§ Gas λΉ„μ©μ„ μ¤„μ΄κΈ° μ„ν•΄μ„ μ–΄μ…λΈ”λ¦¬(Assembly)λ¥Ό μ‚¬μ©ν•μ—¬ κ°™μ€ λ™μ‘μ„ μν–‰ν•  μ μλ‹¤. Paradigmμ [Art Gobblers]λΌλ” NFT ν”„λ΅μ νΈμ μ»¨νΈλ ‰νΈλ¥Ό μμ‹λ΅ μ‚΄ν΄λ³΄μ.  
-->

<h3 id="reference">Reference</h3>
<ol>
  <li><a href="https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/">Ethereum Foundationβ€™s Blog Post for Merkle Proof</a></li>
  <li><a href="https://github.com/OpenZeppelin/merkle-tree">OpenZeppelinβ€™s Github for Merkle Tree</a></li>
  <li><a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5">Belavadi Prahaladβ€™s Medium Post for Merkle Proof</a></li>
</ol>

:ET