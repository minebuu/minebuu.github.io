I"Ñ[<h3 id="introduction">Introduction</h3>
<p>NFT í”„ë¡œì íŠ¸ì—ì„œ í™”ì´íŠ¸ ë¦¬ìŠ¤íŠ¸ ëª…ë‹¨ë§Œ NFT ë¯¼íŒ…ì´ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” ì‹œë‚˜ë¦¬ì˜¤ì²˜ëŸ¼, íŠ¹ì •í•œ ì£¼ì†Œ ë¦¬ìŠ¤íŠ¸ë“¤ë§Œ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ë¥¼ ì‘ì„±í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ? ì´ë”ë¦¬ì›€ì˜ ì €ì¥ ê³µê°„ê³¼ ë¹„ìš©ì— ì œì•½ì´ ì—†ë‹¤ë©´ ëª¨ë“  ì£¼ì†Œ ë¦¬ìŠ¤íŠ¸ë“¤ì„ Storageì— ë§¤í•‘ í˜•íƒœë¡œ ì €ì¥í•œ í›„, íŠ¸ëœì­ì…˜ ìš”ì²­ ì‹œ msg.senderê°€ ë§¤í•‘ ê°’ì„ ê°–ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ í•˜ë‚˜ì˜ ë°©ë²•ì¼ ê²ƒì´ë‹¤. í•˜ì§€ë§Œ ì´ë”ë¦¬ì›€ ë„¤íŠ¸ì›Œí¬ëŠ” ìˆ˜ ë§ì€ ì»´í“¨í„°ê°€ ìƒíƒœë¥¼ ê³µìœ í•˜ëŠ” ì›”ë“œ ì»´í“¨í„°ë¡œì„œ, ì´ëŸ¬í•œ ì›”ë“œ ì»´í“¨í„°ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ê²ƒì€ ë§ì€ ë¹„ìš©ì´ ì†Œëª¨ëœë‹¤ (32 bytesì˜ wordë¥¼ ì €ì¥í•˜ëŠ” ê²ƒì€ í†µìƒì ìœ¼ë¡œ 20,000 gasë¥¼ ì†Œëª¨, ê¸€ì“´ ì‹œì  ê¸°ì¤€ ì•½ 8ì²œì›).</p>

<p>ì´ëŸ¬í•œ ê³µê°„ê³¼ ë¹„ìš©ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ì—ì„œëŠ” Merkle Proofë¼ëŠ” ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤. Merkle Proofë¥¼ ì´ìš©í•˜ë©´ ëª¨ë“  ì£¼ì†Œ ë°ì´í„°ë¥¼ Storageì— ì €ì¥í•˜ì§€ ì•Šê³ ë„, íŠ¹ì • ì£¼ì†Œ ë°ì´í„°ê°€ í•¨ìˆ˜ ì‹¤í–‰ í—ˆìš© ì£¼ì†Œ ëª©ë¡ì— ë“¤ì–´ê°€ëŠ”ì§€ ì•„ë‹Œì§€ë¥¼ íŒë‹¨í•  ìˆ˜ ìˆë‹¤. ì¦‰ ëª¨ë“  ë°ì´í„° (ì—¬ê¸°ì„  ì£¼ì†Œ ë¦¬ìŠ¤íŠ¸)ë¥¼ ì´ë”ë¦¬ì›€ ì˜¨ì²´ì¸ì— ì €ì¥í•˜ì§€ ì•Šê³ ë„ ì•„ì£¼ ì‘ì€ ì˜¨ì²´ì¸ ë°ì´í„°ë§Œìœ¼ë¡œë„ (ë’¤ì— ë‚˜ì˜¬ Merkle Treeì˜ Root ê°’), íŠ¹ì • ë°ì´í„°ì˜ ë¬´ê²°ì„±(Data integrity)ì„ ê²€ì¦í•  ìˆ˜ ìˆë‹¤.</p>

<h3 id="merkle-proof-and-merkle-tree">Merkle Proof and Merkle Tree</h3>
<p>Merkle ProofëŠ” ë¨¸í´ íŠ¸ë¦¬(Merkle Tree)ë¥¼ ì‚¬ìš©í•œë‹¤. ì•„ë˜ ê·¸ë¦¼ê³¼ ê°™ì´ ë¨¸í´ íŠ¸ë¦¬ì˜ Leaf ë…¸ë“œëŠ” ë°ì´í„°ì˜ í•´ì‹œ ê°’ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, Leaf ë…¸ë“œê°€ ì•„ë‹Œ ëª¨ë“  ë…¸ë“œë“¤ì€ ìì‹ ë…¸ë“œ ë‘˜ì˜ í•´ì‹œ ê°’ì„ ê°€ì§„ë‹¤. Leaf ë…¸ë“œì˜ ë°ì´í„° ê°’ì´ í•˜ë‚˜ë¼ë„ ë³€ê²½ëœë‹¤ë©´, í•´ì‹œ í•¨ìˆ˜ì˜ ê²°ê³¼ ê°’ì´ ê³„ì¸µë§ˆë‹¤ ì—°ì‡„ì ìœ¼ë¡œ ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì— Root nodeì˜ í•´ì‹œ ê°’ì´ ì™„ì „íˆ ë‹¬ë¼ì§€ê²Œ ëœë‹¤. ìš°ë¦¬ëŠ” ì´ Root Hash ê°’ë§Œì„ ì´ë”ë¦¬ì›€ ì˜¨ì²´ì¸ì— ì €ì¥í•¨ìœ¼ë¡œì¨ íŠ¹ì • ë°ì´í„°ê°€ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ê²€ì¦í•  ìˆ˜ ìˆë‹¤. ì˜ˆì‹œë¥¼ ë“¤ì–´ ë³´ì.</p>

<p style="text-align: center;">
	<img src="http://localhost:4000/assets/images/MerkleProof/tree.png" alt="Drawing" style="max-width: 80%; height: auto;" />
</p>

<p>ìœ„ ê·¸ë¦¼ì—ì„œ Leaf ë…¸ë“œ H(K)ê°€ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì— í¬í•¨ëœë‹¤ëŠ” ê²ƒì„ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ì—ì„œ ì–´ë–»ê²Œ ì¦ëª…í•  ìˆ˜ ìˆì„ê¹Œ? ì—¬ê¸°ì„œ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì˜ Root Hash ê°’ H(ABCDEFGHIJKLMNOP)ì€ ì˜¨ì²´ì¸ì— ì €ì¥ë˜ì–´ í¼ë¸”ë¦­í•˜ê²Œ ê³µê°œë˜ì–´ ìˆë‹¤ê³  ê°€ì •í•´ë³´ì. ìš°ë¦¬ëŠ” ìœ„ ê·¸ë¦¼ì—ì„œ ìƒ‰ì¹ ëœ ë…¸ë“œë“¤ë§Œ ìˆë‹¤ë©´ í•´ì‹œ ê³„ì‚°ì„ í†µí•´ Root Hash ê°’ì„ ë„ì¶œí•  ìˆ˜ ìˆë‹¤. ê³„ì‚°ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.</p>

<ol>
  <li>H(K)ì„ H(L)ì™€ í•´ì‹±í•˜ì—¬ H(KL)ì„ ê³„ì‚°</li>
  <li>H(KL)ì„ H(IJ)ì™€ í•´ì‹±í•˜ì—¬ H(IJKL)ì„ ê³„ì‚°</li>
  <li>H(IJKL)ì„ H(MNOP)ì™€ í•´ì‹±í•˜ì—¬ H(IJKLMNOP)ì„ ê³„ì‚°</li>
  <li>H(IJKLMNOP)ì„ H(ABCDEFGH)ì™€ í•´ì‹±í•˜ì—¬ Root Hashì¸ H(ABCDEFGHIJKLMNOP)ì„ ê³„ì‚°</li>
</ol>

<p>ë”°ë¼ì„œ H(K)ë¡œë¶€í„° Root Hash ê°’ì„ êµ¬í•˜ê¸° ìœ„í•´ì„  [ H(K), H(L), H(IJ), H(MNOP), H(ABCDEFGH)] ê°’ë“¤ì´ í•„ìš”í•˜ë‹¤. ìœ„ ê³¼ì •ì„ í†µí•´ ê³„ì‚°ëœ Root Hash ê°’ì´ ë¯¸ë¦¬ ì˜¨ì²´ì¸ì— ì €ì¥ë˜ì–´ ìˆë˜ Root Hash ê°’ê³¼ ì¼ì¹˜í•œë‹¤ë©´ ìš°ë¦¬ëŠ” Leaf H(K)ê°€ H(ABCDEFGHIJKLMNOP)ë¥¼ Root Hashë¡œ ê°€ì§€ëŠ” ë¨¸í´ íŠ¸ë¦¬ì— í¬í•¨ë˜ì—ˆë‹¤ê³  íŒë‹¨í•  ìˆ˜ ìˆë‹¤.</p>

<p>Warning: ìœ„ í•´ì‹œí•¨ìˆ˜ ê³„ì‚° ê³¼ì •ì—ì„  í•´ì‹œí•¨ìˆ˜ íŒŒë¼ë¯¸í„°ë“¤ì˜ ìˆœì„œ(order)ë¥¼ ë¬´ì‹œí•˜ì˜€ì§€ë§Œ, H(H(KL), H(IJ))ì˜ ê°’ì€ H(H(IJ), H(KL))) ê°’ê³¼ ì „í˜€ ë‹¤ë¥¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì‹¤ì œ êµ¬í˜„ì—ì„  íŒŒë¼ë¯¸í„°ì˜ ìˆœì„œ í˜¹ì€ Concat ìˆœì„œì— ìœ ì˜í•´ì•¼í•œë‹¤. ì•„ë˜ ì‚´í´ë³¼ OpenZeppelin ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” H(IJ)ì™€ H(KL)ì˜ ê°’ì˜ í¬ê¸°ë¥¼ ë¹„êµí•˜ì—¬ ì •ë ¬í•œë‹¤. ì¦‰ H(IJ)ê°€ H(KL)ë³´ë‹¤ í´ ë•Œ, H(concat(H(IJ),H(KL)))ì„ ìˆ˜í–‰í•˜ê³ , ë°˜ëŒ€ì˜ ê²½ìš°ì—” H(concat(H(KL),H(IJ)))ë¥¼ ìˆ˜í–‰í•œë‹¤.</p>

<p>ìœ„ì˜ ì˜ˆì œì²˜ëŸ¼ íŠ¹ì • ë°ì´í„°(A to P)ë“¤ì˜ ì§‘í•©ì´ ìˆì„ ë•Œ, ìš°ë¦¬ëŠ” ì´ ë°ì´í„°ë“¤ì˜ í•´ì‹œ ê°’ì„ Leaf ë…¸ë“œë¡œ í•˜ì—¬ ë¨¸í´ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤. ì´ ë•Œ Merkle ProofëŠ” íŠ¹ì • ë°ì´í„°ê°€ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì— ì†í•´ìˆëŠ”ì§€ë¥¼ ê²€ì¦í•˜ëŠ” ë°©ë²•ì´ë‹¤. ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ ìŠ¤í† ë¦¬ì§€ì— ë¨¸í´ íŠ¸ë¦¬ì˜ Root Hash ê°’ì„ ë¯¸ë¦¬ ì €ì¥í•˜ê³ , ì¶”í›„ ì‚¬ìš©ìê°€ íŠ¹ì • ë°ì´í„°ê°€ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì— ì†í•´ìˆëŠ”ì§€ ì¦ëª…í•˜ê¸° ìœ„í•´ Proofë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œ ProofëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ í¬í•¨ í•  í•„ìš” ì—†ì´, Root Hashë¥¼ ì¬êµ¬ì„±í•˜ê¸° ìœ„í•œ ìµœì†Œí•œì˜ ê°’ë“¤ë§Œì„ í¬í•¨í•˜ë©´ ëœë‹¤ (ì•ì„  ì˜ˆì‹œì—ì„œ ProofëŠ” ëª¨ë“  ë°ì´í„° A,â€¦,P ê°€ ì•„ë‹Œ H(K), H(L), H(IJ), H(MNOP), H(ABCDEFGH)ë§Œ í•„ìš”í•˜ì˜€ë‹¤).</p>

<h3 id="openzeppelinì˜-merkle-proof-ë¼ì´ë¸ŒëŸ¬ë¦¬">OpenZeppelinì˜ Merkle Proof ë¼ì´ë¸ŒëŸ¬ë¦¬</h3>

<p>ì˜¤í”ˆì œí”Œë¦°(OpenZeppelin)ì—ì„œëŠ” Merkle Proofë¥¼ ì•ˆì „í•˜ê³ , ì‰½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë„ë¡ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•˜ê³  ìˆë‹¤. Merkle Treeì™€ Proofë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ <a href="https://github.com/OpenZeppelin/merkle-tree">Javascript ë¼ì´ë¸ŒëŸ¬ë¦¬</a>ì™€, ì´ë¥¼ ì˜¨ì²´ì¸ìƒì—ì„œ ê²€ì¦í•˜ê¸° ìœ„í•œ <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol">Merkle Proof ì†”ë¦¬ë””í‹° ë¼ì´ë¸ŒëŸ¬ë¦¬</a>ê°€ ë³„ê°œë¡œ ì¡´ì¬í•œë‹¤.</p>

<p>ì˜¤í”ˆì œí”Œë¦°ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„  ì´ë”ë¦¬ì›€ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ë¥¼ ìœ„í•œ â€œí‘œì¤€â€ ë¨¸í´ íŠ¸ë¦¬(Standard Merkle Trees)ë¥¼ ì‚¬ìš©í•œë‹¤. ìŠ¤íƒ ë‹¤ë“œ ë¨¸í´ íŠ¸ë¦¬ì˜ íŠ¹ì§•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.</p>

<ul>
  <li>ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì´ë‹¤</li>
  <li>LeavesëŠ” í¬ê¸°ê°€ í° ìˆœë¶€í„° ì‘ì€ ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆë‹¤</li>
  <li>LeavesëŠ” ì¼ë ¨ì˜ ê°’ì„ ABI encodingí•œ ê²°ê³¼ì´ë‹¤</li>
  <li>Keccak256 í•´ì‹œí•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤</li>
  <li>Second preimage attacksë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ LeavesëŠ” ë°ì´í„°ë¥¼ ë‘ë²ˆ í•´ì‹±í•œ ê°’ì„ ì‚¬ìš©í•œë‹¤</li>
</ul>

<p>ìœ„ ì‚¬í•­ë“¤ ì¤‘ ì•„ë˜ 3ê°€ì§€ ì‚¬í•­ì„ ê³ ë ¤í•  ë•Œ LeafëŠ” ì†”ë¦¬ë””í‹°ì—ì„œ ì•„ë˜ì™€ ê°™ì´ í‘œí˜„ëœë‹¤.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes32</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="kt">bytes</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">amount</span><span class="p">))));</span>
</code></pre></div></div>

<p>ê·¸ëŸ¼ ì´ì œ ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•´ ìŠ¤íƒ ë‹¤ë“œ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•´ë³´ì. â€œnpm install @openzeppelin/merkle-treeâ€ ëª…ë ¹ì–´ë¥¼ í†µí•´ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆë‹¤. ìš°ë¦¬ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•´ í•„ìš”í•œ ë°ì´í„°ë¡œë¶€í„° Merkle Treeë¥¼ ìƒì„±í•˜ê³ , íŠ¹ì • ë°ì´í„°ì˜ Proofë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤. ë˜í•œ Treeë¥¼ Json íŒŒì¼ë¡œ ì €ì¥í•˜ì—¬, í¼ë¸”ë¦­ì— ê³µê°œí•´ ëˆ„êµ¬ë‚˜ treeë¥¼ ì¬êµ¬ì„±í•˜ê³ , proofë¥¼ ìƒì„±í•˜ë„ë¡ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì‚´í´ë³´ì.</p>

<pre><code class="language-Javascript">import { StandardMerkleTree } from "@openzeppelin/merkle-tree";
import fs from "fs";

// (1) Data
const values = [
  ["0x1111111111111111111111111111111111111111", "3000000000000000000"],
  ["0x2222222222222222222222222222222222222222", "0"],
  ["0x3333333333333333333333333333333333333333", "30"],
  ["0x4444444444444444444444444444444444444444", "1500000000000000000"],
];

// (2) ë°ì´í„°ë¡œë¶€í„° StandardMerkleTree ìƒì„±
const tree = StandardMerkleTree.of(values, ["address", "uint256"]);

// (3) ìƒì„±í•œ standard merkle tree ì¶œë ¥
console.log("Tree:\n" + tree.render());

// (4) ìƒì„±í•œ ë¨¸í´ íŠ¸ë¦¬ë¥¼ json fileë¡œ ì €ì¥
fs.writeFileSync("tree.json", JSON.stringify(tree.dump()));

// (5) json íŒŒì¼ë¡œ ì €ì¥ëœ ë¨¸í´ íŠ¸ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ê¸°
const tree_load = StandardMerkleTree.load(JSON.parse(fs.readFileSync("tree.json")));

// (6) ë‚´ê°€ ì›í•˜ëŠ” ë°ì´í„°ì˜ indexë¥¼ ì°¾ê¸° ìœ„í•´ entries() í•¨ìˆ˜ë¥¼ í†µí•œ Loopë¬¸ ì‹¤í–‰
for (const [i, v] of tree_load.entries()) {
 if (v[0] === '0x1111111111111111111111111111111111111111') {
   // (7) entryì˜ indexë¥¼ ì‚¬ìš©í•´ ì›í•˜ëŠ” ë°ì´í„°ì˜ proofë¥¼ ìƒì„±
   const proof = tree_load.getProof(i);
   console.log('Value:', v);
   console.log('Proof:', proof);
 }
}
</code></pre>

<p>ìœ„ ì½”ë“œì—ì„œ, ìš°ë¦¬ëŠ” í•˜ë‚˜ì˜ ë°ì´í„°ë¥¼ [â€œaddressâ€, â€œuint256â€] ê°’ìœ¼ë¡œ êµ¬ì„±í•˜ì˜€ë‹¤. (2)ë²ˆ StandardMerkleTreeë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì—ì„œ ì´ëŸ¬í•œ ë°ì´í„° Typeì„ ì•Œë ¤ì¤Œìœ¼ë¡œì¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ Solidity ABI.encodeì— ë§ì¶° ë°ì´í„°ë¥¼ ì¸ì½”ë”© í•  ìˆ˜ ìˆê²Œí•œë‹¤.</p>

<p>(3)ë²ˆì—ì„œ tree.render() í•¨ìˆ˜ë¥¼ í†µí•´ ì½˜ì†”ì— ì¶œë ¥í•œ ë¨¸í´ íŠ¸ë¦¬ì˜ ê°’ì€ ì•„ë˜ì™€ ê°™ë‹¤. 3, 4, 5, 6ë²ˆ ë…¸ë“œëŠ” Leaf ë…¸ë“œë¡œì„œ, ì•ì„œ ë§í•œ Standard Merkle Treeì˜ íŠ¹ì§•ìœ¼ë¡œ ë§í–ˆ ë“¯ Dataë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë°ì´í„°ì— ëŒ€í•´ Kecca256 í•´ì‹œí•¨ìˆ˜ë¥¼ ë‘ë²ˆ ì‹¤í–‰í•œ ê°’ì´ë‹¤. ì—¬ê¸°ì„œ 0ë²ˆ ë…¸ë“œì¸ â€œb56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27â€ ê°’ì€ Root Hash ê°’ìœ¼ë¡œì„œ ì»¨íŠ¸ë ‰íŠ¸ì— ê³µê°œì ìœ¼ë¡œ ì €ì¥ë˜ì–´ì•¼í•  ê°’ì´ë‹¤.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:
0) b56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27
â”œâ”€ 1) 5cad1d68954860301ed48598eea08649201682d2b50c9977d697cb153e0d3618
â”‚  â”œâ”€ 3) fdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2f
â”‚  â””â”€ 4) 81722ecd3bc2b003be5b8850a4de98dc3e991dd001e8173e408de279c388bc2e
â””â”€ 2) b77c1086d6ac2a0e454607cbe31c25dd5736f1bf9c147a6de93cc7121b7d210b
   â”œâ”€ 5) 43ab72a115a26a347338741504964163dea922ee399341883ba5705ea9a4f7d6
   â””â”€ 6) 4358fbda895975ea76fcee263adef8867647f91879de2c1a3c257821709287a5
</code></pre></div></div>

<p>ì—¬ê¸°ì„œ Leaf ë…¸ë“œì˜ ìˆœì„œëŠ” ë°ì´í„°ì˜ ì…ë ¥ ìˆœì„œ(Values ë°°ì—´ì˜ ì¸ë±ìŠ¤ ìˆœì„œ)ê°€ ì•„ë‹ˆë¼ëŠ” ì ì„ ëª…ì‹¬í•´ì•¼í•œë‹¤. Leaf ë…¸ë“œëŠ” ì•ì„œ ë§í–ˆ ë“¯, í¬ê¸°ì— ë”°ë¼ â€˜ì •ë ¬â€™ëœë‹¤. ì²«ë²ˆì§¸ Leaf ë…¸ë“œ â€œfdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2fâ€ê°€ ê°€ì¥ í° ê°’ì„ ê°€ì§ì„ í™•ì¸í•  ìˆ˜ ìˆìœ¼ë©° ì´ ê°’ì€ Values[0]ì¸ [â€œ0x1111111111111111111111111111111111111111â€, â€œ3000000000000000000â€]ì„ ë‘ë²ˆ í•´ì‹±í•œ ê°’ì´ ì•„ë‹Œ, Values[3]ì„ ë‘ë²ˆ í•´ì‹±í•œ ê°’ì´ë‹¤. ì•„ë˜ ì½”ë“œë¥¼ í†µí•´ ìš°ë¦¬ëŠ” ì´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.</p>

<pre><code class="language-Javascript">const leaf = tree.leafHash(values[3]);
console.log("Leaf of values[3]: " + leaf);
</code></pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Leaf of values[3]: 0xfdb74f493e905caded8ad7315cf41616f81342fd1fcaf89145801702c4239c2f
</code></pre></div></div>

<p>ì¦‰, ì˜¤í”ˆì œí”Œë¦°ì—ì„œ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ ë¨¸í´ íŠ¸ë¦¬ì—ì„  ë°ì´í„°ë“¤ì— ëŒ€í•´ Kecca256 í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì—¬ í•´ì‹œ ê°’ì„ ë¨¼ì € êµ¬í•œ í›„, í¬ê¸°ê°€ í° ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ Leaf ë…¸ë“œë¡œ ì‚¼ëŠ”ë‹¤.</p>

<p>ë‹¤ì‹œ ë³¸ë˜ ì½”ë“œë¡œ ëŒì•„ì™€ (6)ë²ˆ ê³¼ì •ì„ ì‚´í´ë³´ì.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (6) ë‚´ê°€ ì›í•˜ëŠ” ë°ì´í„°ì˜ indexë¥¼ ì°¾ê¸° ìœ„í•´ entries() í•¨ìˆ˜ë¥¼ í†µí•œ Loopë¬¸ ì‹¤í–‰</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">tree_load</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">0x1111111111111111111111111111111111111111</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// (7) entryì˜ indexë¥¼ ì‚¬ìš©í•´ ì›í•˜ëŠ” ë°ì´í„°ì˜ proofë¥¼ ìƒì„±</span>
   <span class="kd">const</span> <span class="nx">proof</span> <span class="o">=</span> <span class="nx">tree_load</span><span class="p">.</span><span class="nx">getProof</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Value:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Proof:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">proof</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>ìš°ë¦¬ëŠ” ìƒì„±í•œ ë¨¸í´ íŠ¸ë¦¬ì—ì„œ íŠ¹ì • ë°ì´í„°ë¥¼ ìœ„í•œ Proofë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤. ì˜ˆì œì—ì„ , â€œ0x1111111111111111111111111111111111111111â€ì˜ ì£¼ì†Œë¥¼ ê°€ì§„ ë°ì´í„°ë¥¼ ìœ„í•´ Proofë¥¼ ìƒì„±í•œë‹¤. Proofë¥¼ ì¶œë ¥í•œ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proof: [
  '0x4358fbda895975ea76fcee263adef8867647f91879de2c1a3c257821709287a5',
  '0x5cad1d68954860301ed48598eea08649201682d2b50c9977d697cb153e0d3618'
]
</code></pre></div></div>

<p>ìš°ë¦¬ëŠ” ì´ Proofë¥¼ â€œ0x1111111111111111111111111111111111111111â€ì˜ Leaf í•´ì‹œ ê°’ê³¼ í•¨ê»˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ì— ë³´ë‚´ë©´ ì»¨íŠ¸ë ‰íŠ¸ëŠ” ì´ë¥¼ í†µí•´ Root hash ê°’ì„ ë„ì¶œí•  ìˆ˜ ìˆë‹¤. ë„ì¶œëœ ê°’ì´ ì»¨íŠ¸ë ‰íŠ¸ì— ìŠ¤í† ë¦¬ì§€ì— ì‚¬ì „ì— ì €ì¥ëœ Root Hash ê°’ì¸ â€œb56f9de6e47f3f111e77cca1c44d90b31d4e140910a68734860a5c3da76a4b27â€ê³¼ ë™ì¼í•˜ë‹¤ë©´, ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ëŠ” ì´ ë°ì´í„°ê°€ í•´ë‹¹ ë¨¸í´ íŠ¸ë¦¬ì— ì†í•´ìˆëŠ” ë°ì´í„°ë¼ê³  íŒë‹¨í•  ìˆ˜ ìˆë‹¤.</p>

<p>ê·¸ëŸ¼ ìœ„ ê³¼ì •ì„ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ì—ì„œ ì‹¤ì œë¡œ ì–´ë–»ê²Œ êµ¬í˜„í–ˆëŠ”ì§€ <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol">ì˜¤í”ˆì œí”Œë¦°ì˜ ì»¨íŠ¸ë ‰íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬</a>ë¥¼ ì‚´í´ë³´ì.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">library</span> <span class="n">MerkleProof</span> <span class="p">{</span>
    <span class="cm">/**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */</span>
    <span class="k">function</span> <span class="n">verify</span><span class="p">(</span>
        <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">proof</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="n">root</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="n">leaf</span>
    <span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">processProof</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">==</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs &amp; pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */</span>
    <span class="k">function</span> <span class="n">processProof</span><span class="p">(</span><span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">proof</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">leaf</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="n">computedHash</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">proof</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">computedHash</span> <span class="o">=</span> <span class="n">_hashPair</span><span class="p">(</span><span class="n">computedHash</span><span class="p">,</span> <span class="n">proof</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">computedHash</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">_hashPair</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">_efficientHash</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">/// @solidity memory-safe-assembly
</span>        <span class="k">assembly</span> <span class="p">{</span>
            <span class="n">mstore</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">mstore</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">:=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>ìœ„ ì½”ë“œëŠ” ë³¸ë˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ verifyì™€ ê´€ë ¨ëœ í•¨ìˆ˜ë§Œì„ ë³´ì—¬ì¤€ë‹¤.</p>

<h3 id="nft-í”„ë¡œì íŠ¸ì—ì„œì˜-ì‹¤ì œ-í™œìš©">NFT í”„ë¡œì íŠ¸ì—ì„œì˜ ì‹¤ì œ í™œìš©</h3>

<p>ì•ì„œ Introì—ì„œ ê°„ë‹¨íˆ ë§í–ˆ ë“¯, ë§ì€ NFT í”„ë¡œì íŠ¸ì—ì„œ White list (WL) ë¯¼íŒ…ì„ ì§„í–‰í•˜ê³ ì í•  ë•Œ ë¨¸í´ íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•œë‹¤. ëª¨ë“  WL ì£¼ì†Œë¥¼ ì˜¨ì²´ì¸ì— ì €ì¥í•  í•„ìš” ì—†ì´, ì£¼ì†Œ ë°ì´í„°ë¡œ êµ¬ì„±ëœ ë¨¸í´ íŠ¸ë¦¬ì˜ Root Hash ê°’ë§Œ ì˜¨ì²´ì¸ì— ì €ì¥í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤. ì•„ë˜ëŠ” ì˜¤í”ˆì œí”Œë¦°ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì»¨íŠ¸ë ‰íŠ¸ì´ë‹¤. Mint í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” íŠ¸ëœì­ì…˜ì˜ msg.senderê°€ ë¨¸í´ íŠ¸ë¦¬ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ê²€ì¦í•œë‹¤. ë‹¨ìˆœí•¨ì„ ìœ„í•´ ìµœëŒ€í•œ ê°„ê²°í•˜ê²Œ ì‘ì„±ë˜ì—ˆë‹¤.</p>

<pre><code class="language-Solidity">import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/// @notice Merkle root of mint mintlist.
bytes32 public immutable merkleRoot;

/// @param _merkleRoot Merkle root of mint mintlist.
constructor(bytes32 _merkleRoot) Owned(msg.sender) {
    merkleRoot = _merkleRoot;   
}


/// limit is enforced during the creation of the merkle proof, which will be shared publicly.
/// @param proof Merkle proof to verify the sender is mintlisted.
/// @return gobblerId The id of the gobbler that was claimed.
function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {
    // If minting has not yet begun, revert.
    if (mintStart &gt; block.timestamp) revert MintStartPending();

    // If the user has already claimed, revert.
    if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();

    // If the user's proof is invalid, revert.
    if (!MerkleProof.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();

    hasClaimedMintlistGobbler[msg.sender] = true;

    unchecked {
        // Overflow should be impossible due to supply cap of 10,000.
        emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);
    }

    _mint(msg.sender, gobblerId);
}
</code></pre>

<h3 id="gas-optimization-assembly">Gas Optimization (Assembly)</h3>

<p>ìœ„ì˜ OpenZeppelinì´ ì‘ì„±í•œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë ‰íŠ¸ ì½”ë“œëŠ” ì–´ì…ˆë¸”ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë™ì‘í•œë‹¤. ëŒ€ë¶€ë¶„ì˜ í”„ë¡œì íŠ¸ë“¤ì€ í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•œë‹¤. ë‹¤ë§Œ Gas ë¹„ìš©ì„ ì¤„ì´ê¸° ìœ„í•´ì„œ ì–´ì…ˆë¸”ë¦¬(Assembly)ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°™ì€ ë™ì‘ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. Paradigmì˜ <a href="https://github.com/artgobblers/art-gobblers/blob/master/src/ArtGobblers.sol#L347">Art Gobblers</a>ë¼ëŠ” NFT í”„ë¡œì íŠ¸ì˜ ì»¨íŠ¸ë ‰íŠ¸ë¥¼ ì˜ˆì‹œë¡œ ì‚´í´ë³´ì.</p>

<h3 id="reference">Reference</h3>
<ol>
  <li><a href="https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/">Ethereum Foundationâ€™s Blog Post for Merkle Proof</a></li>
  <li><a href="https://github.com/OpenZeppelin/merkle-tree">OpenZeppelinâ€™s Github for Merkle Tree</a></li>
  <li><a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5">Belavadi Prahaladâ€™s Medium Post for Merkle Proof</a></li>
</ol>

:ET